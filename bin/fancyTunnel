-- Dig a fancy straight tunnel
-- #####
-- ##+##
-- #+++#
-- #+++#
-- #+++#
-- #*++#
-- #####
-- Start at the * one block back and mine out that size thingy until running out of fuel

local Version = "v1.0.0"
local LengthQuestion = true

local lengthVar = 0 -- how far have we gotten?
local desiredLength  -- filled later

--Total number of collected items
local collected = 0

-- Functions to do work with
function version() -- Version function
    return Version
end

function regwrite(string, columnVar, rowVar) -- Write a string to the cords
    term.setCursorPos( columnVar, rowVar )
    write (string)
end

function clearscreen() -- Clearscreen function
    term.clear()
    regwrite( "Fancy Tunnel", 12, 1 )
    regwrite( version(), 2, 12 )
    regwrite( "Developed by BeepDog", 17, 12 )
    term.setCursorPos( 1, 3 )
end

--A fairly naieve refueling algorithm
function refuel(amount)
  local fuelLevel = turtle.getFuelLevel()
  if fuelLevel == "unlimited" then
    return true
  end

  local needed = amount -- TODO: or how much fuel to mine the tunnel out
  if turtle.getFuelLevel() < needed then
    local fueled = false
    for n=1,16 do
      if turtle.getItemCount(n) > 0 then
        turtle.select(n)
        if turtle.refuel(1) then
          while turtle.getItemCount(n) > 0 and turtle.getFuelLevel() < needed do
            turtle.refuel(1)
          end
          if turtle.getFuelLevel() >= needed then
            -- Got enough fuel, set the selector back to one and return yep
            turtle.select(1)
            return true
          end
        end
      end
    end
    -- couldn't find any fuel, or couldn't satisfy needed fuel values
    turtle.select(1)
    return false
  end
  -- Has enough fuel
  return true
end

-- Determine if we can collect the item that we possibly just mined or something
local function collect()
  local bFull = true
  local nTotalItems = 0
  for n=1,16 do
    local nCount = turtle.getItemCount(n)
    if nCount == 0 then
      bFull = false
    end
    nTotalItems = nTotalItems + nCount
  end

  if nTotalItems > collected then
    collected = nTotalItems
    print("Collected " .. collected .. " items")
  end
  if bFull then
    print("No empty slots left!")
    return false
  end
  return true
end

--Head Forward
function mineForward()
  refuel(1)
  while not turtle.forward() do
    mineDir("forward")
  end
  --TODO set position knowledge in here
end

-- Takes a direction and then will make sure that direction is empty (handling gravel n such)
function mineDir(direction)
  local fdetect
  local fdig

  if direction == "up" then
    fdetect = turtle.detectUp
    fdig = turtle.digUp
  elseif direction == "down" then
    fdetect = turtle.detectDown
    fdig = turtle.digDown
  else  -- must be forward!
    fdetect = turtle.detect
    fdig = turtle.dig
  end

  while fdetect() do
    refuel(1)
    if fdig() then
      collect() --TODO: this should be smarter...
      sleep(0.5) -- only sleep once digged
    else
      return false --why return false here?
    end

  end
end


--Mines up and moves up...
function mineUp()
  refuel(1)
  while not turtle.up() do
    mineDir("up")
  end
end

--Make sure that when we mine up a square, it stays empty
function emptyUp()
  mineDir("up")
end

--Mines out a slot of the tunnel
-- #####
-- ##+##
-- #+++#
-- #+++#
-- #+++#
-- #*++#
-- #####
function mineSlot()
  refuel(22) -- one slot for the wall is 22 operations, possibly not the most efficient
  mineForward() --move into the slot to begin mining
  mineDir("up")
  mineDir("down")
  turtle.turnRight()

  mineForward()
  emptyUp()
  mineDir("down")

  mineForward()
  emptyUp()
  mineDir("down")

  -- Move Up into top right corner
  turtle.up()
  turtle.turnLeft()
  mineUp()

  -- Prepare to mine back
  turtle.turnLeft()
  mineForward()
  mineDir("up")
  mineForward()

  --Return to start position for next round
  --TODO replace all down calls iwth make sure we can actually go down calls
  turtle.down()
  turtle.down()
  turtle.turnRight()
end


-- Main logic
clearscreen()
while LengthQuestion == true do 
    print("Length of the tunnel?")
    local length = tonumber(read())
    clearscreen()
    if length == nil then
        print("Please answer with a number.")
    elseif length > 0 then
        LengthQuestion = false
        desiredLength = length --EW GLOBALS did this even work?
    else
        print("The tunnel length must be positive.")
    end
end

clearscreen()
print("Would have made a tunnel " .. lengthVar .. " long")

--Start mining logic here!
refuel(1)
turtle.up() --start up one square from where things are
--Calculate how much fuel is needed for the entire thing
local totalFuel = lengthVar * 22
refuel(totalFuel)

while lengthVar < desiredLength do
  --MINE DAT TUNEL
  lengthVar = lengthVar +1
  mineSlot()
end

print("COMPLETED")

--Now it should return to start...
refuel( lengthVar + 2)
turtle.down()
while lengthVar > 0 do
  lengthVar = lengthVar - 1
  turtle.back()
end

-- vim: set filetype=lua :
