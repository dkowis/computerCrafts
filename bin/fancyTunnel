-- Dig a fancy straight tunnel
-- #####
-- ##+##
-- #+++#
-- #+++#
-- #+++#
-- #*++#
-- #####
-- Start at the * one block back and mine out that size thingy until running out of fuel

local Version = "v1.0.0"
local LengthQuestion = true

local lengthVar = 0 -- how far have we gotten?
local desiredLength  -- filled later

--Total number of collected items
local collected = 0

-- Load up my APIs
os.loadAPI("shlrm/api/sturtle")
os.loadAPI("shlrm/api/sdig")

-- Functions to do work with
function version() -- Version function
    return Version
end

function regwrite(string, columnVar, rowVar) -- Write a string to the cords
    term.setCursorPos( columnVar, rowVar )
    write (string)
end

function clearscreen() -- Clearscreen function
    term.clear()
    regwrite( "Fancy Tunnel", 12, 1 )
    regwrite( version(), 2, 12 )
    regwrite( "Developed by BeepDog", 17, 12 )
    term.setCursorPos( 1, 3 )
end

-- Determine if we can collect the item that we possibly just mined or something
local function collect()
  local bFull = true
  local nTotalItems = 0
  for n=1,16 do
    local nCount = turtle.getItemCount(n)
    if nCount == 0 then
      bFull = false
    end
    nTotalItems = nTotalItems + nCount
  end

  if nTotalItems > collected then
    collected = nTotalItems
    print("Collected " .. collected .. " items")
  end
  if bFull then
    print("No empty slots left!")
    return false
  end
  return true
end

--Head Forward
function mineForward()
  sturtle.refuel(1)
  while not turtle.forward() do
    sdig.mineDir("forward")
  end
  --TODO set position knowledge in here
end


--Mines up and moves up...
function mineUp()
  sturtle.refuel(1)
  while not turtle.up() do
    sdig.mineDir("up")
  end
end

--Make sure that when we mine up a square, it stays empty
function emptyUp()
  sdig.mineDir("up")
end

--Mines out a slot of the tunnel
-- #####
-- ##+##
-- #+++#
-- #+++#
-- #+++#
-- #*++#
-- #####
function mineSlot()
  sturtle.refuel(22) -- one slot for the wall is 22 operations, possibly not the most efficient
  mineForward() --move into the slot to begin mining
  sdig.mineDir("up")
  sdig.mineDir("down")
  turtle.turnRight()

  mineForward()
  emptyUp()
  sdig.mineDir("down")

  mineForward()
  emptyUp()
  sdig.mineDir("down")

  -- Move Up into top right corner
  turtle.up()
  turtle.turnLeft()
  mineUp()

  -- Prepare to mine back
  turtle.turnLeft()
  mineForward()
  sdig.mineDir("up")
  mineForward()

  --Return to start position for next round
  --TODO replace all down calls iwth make sure we can actually go down calls
  turtle.down()
  turtle.down()
  turtle.turnRight()
end


-- Main logic
clearscreen()
while LengthQuestion == true do 
    print("Length of the tunnel?")
    local length = tonumber(read())
    clearscreen()
    if length == nil then
        print("Please answer with a number.")
    elseif length > 0 then
        LengthQuestion = false
        desiredLength = length --EW GLOBALS did this even work?
    else
        print("The tunnel length must be positive.")
    end
end

clearscreen()
print("Would have made a tunnel " .. lengthVar .. " long")

--Start mining logic here!
sturtle.refuel(1)
turtle.up() --start up one square from where things are
--Calculate how much fuel is needed for the entire thing
local totalFuel = lengthVar * 22
sturtle.refuel(totalFuel)

while lengthVar < desiredLength do
  --MINE DAT TUNEL
  lengthVar = lengthVar +1
  mineSlot()
end

print("COMPLETED")

--Now it should return to start...
sturtle.refuel( lengthVar + 2)
turtle.down()
while lengthVar > 0 do
  lengthVar = lengthVar - 1
  turtle.back()
end

-- vim: set filetype=lua :
